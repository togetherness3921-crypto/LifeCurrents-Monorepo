---
description: Core development protocols and workflow guidelines for the LifeCurrents project.
alwaysApply: true
---

# LifeCurrents Project Development Rules

## Maintaining Cursor Rules

### File Structure
- Rules are stored in `.cursor/rules/` directory as `.mdc` files
- Each `.mdc` file uses YAML frontmatter followed by Markdown content
- Use kebab-case for filenames (e.g., `api-standards.mdc`)

### YAML Frontmatter Properties
```yaml
---
description: Brief description for AI to decide relevance
globs: pattern/to/match/**/*  # Optional: auto-attach to matching files
alwaysApply: true/false        # Optional: always include in context
---
```

### Rule Types
- **Always Applied**: `alwaysApply: true` - Always included in AI context
- **Auto-Attached**: Has `globs` defined - Included when matching files are referenced
- **Agent Requested**: Has `description` only - AI decides whether to use it
- **Manual**: Empty frontmatter - Only used when explicitly invoked with `@ruleName`

### Best Practices
- Keep rules concise and focused (under 25 lines when possible)
- Use clear, actionable descriptions
- Include both positive and negative examples
- Don't combine `globs` and `description` in the same rule
- Use `@filename` syntax to reference template files for additional context

### Updating Rules
1. Edit the `.mdc` file directly in `.cursor/rules/`
2. Changes take effect immediately in new AI conversations
3. Use numbered prefixes (e.g., `001-`, `100-`, `200-`) to control priority when using multiple rule files

## Modifying System Instructions
- To modify system instructions, edit the corresponding file in the `synced_files/system_instructions/` directory. These changes are automatically synced with the Supabase database via the `auto-sync` script.

## Database Schema and Data Migrations
- To modify the Supabase schema or perform data migrations, do **not** run raw SQL queries directly.
- Instead, modify the `alterCommands` array in `apply_and_verify_schema.cjs` with the required SQL DDL or DML commands.
- Run the script using `node apply_and_verify_schema.cjs`.
- After successful execution, **revert the changes** to the script.

## Console Logging for Usability
- When implementing or modifying any functionality (either locally or through a dispatched job), ensure that appropriate console logs are included to facilitate easier troubleshooting. All logs should be tagged with a descriptive, bracketed identifier.
- **Example:** `console.log('[Auth] User login successful:', userId);`

## Standard Development Workflow: Dispatching Agentic Tasks

Our primary method for making changes to the codebase is a collaborative, semi-automated process. This workflow allows us to dispatch tasks to an AI agent and track them through to completion and integration.

The typical steps are as follows:

1.  **Task Identification:** During our conversation, we will identify a specific development task, bug fix, or feature to be implemented.
2.  **Collaborative Prompting:** We will work together to craft a clear, detailed, and effective prompt that outlines the requirements for the task.
3.  **Job Dispatch:** Once the prompt is finalized, you will use the `dispatch_job` tool to send the task to the automated system. This creates a job record that appears in the local Dashboard UI.
4.  **Automated Execution:** The system will then trigger a GitHub Action that uses the Claude agent to perform the coding task, commit the result to a new branch, and create a pull request.
5.  **Preview and Verification:** A preview deployment is automatically generated for the pull request. The user will use the link in the Dashboard UI to access the preview and verify that the changes meet the requirements, using the provided verification steps.
6.  **Approval:** Using the Dashboard UI, the user will mark the verified jobs as "Ready for Integration."
7.  **Final Reconciliation:** When ready, the user will give you an instruction to integrate the approved changes. You will then execute the Job Reconciliation Workflow noted below to merge the code into the main branch.

## Job Dispatch Format

When calling `dispatch_job`, provide three required fields:

**1. title:** Brief job name

**2. prompt:** Full implementation instructions with code examples, file locations, and:
```
**Verification Steps:**
1. Visual: [fastest checks first]
2. Interaction: [user actions to test]
3. Deployment: [PR/preview checks]
```

**3. integration_summary:** Comprehensive reconciliation context
- What is changing and why (no length limit)
- Key details (colors, elements, values)
- Original intent and purpose
- Used when merging multiple jobs that modify same files
- Omit implementation details (how)

**Example integration_summary:**
"Add blue (#2B5B84) background to Job Queue header frame (header_frame in create_job_list method). Purpose: Visual hierarchy - distinguish header from content area. Complements text styling changes to same element."

## Job Reconciliation Workflow

When instructed to **reconcile, integrate, or commit** completed jobs:

1. Call `get_ready_jobs` MCP tool â†’ Returns jobs with diffs and integration_summary
2. List all changes from diffs
3. Apply changes one at a time using `search_replace`/`write` tools per Integration Protocol below
4. Run: `node integrate-jobs.cjs "title1" "title2" ...`
5. Call `mark_jobs_integrated` MCP tool with job IDs

### Integration Protocol

**THIS IS INTEGRATION, NOT REIMPLEMENTATION.**

- Apply each diff change exactly as written unless it conflicts
- Where conflicts exist, use integration_summary context to resolve intelligently
- Favor reusing existing work over rewriting
- Evaluate each change individually before applying
- After all changes applied, report any conflicts encountered
