---
description: Core development protocols and workflow guidelines for the LifeCurrents project.
alwaysApply: true
---

# LifeCurrents Project Development Rules

## Maintaining Cursor Rules

### File Structure
- Rules are stored in `.cursor/rules/` directory as `.mdc` files
- Each `.mdc` file uses YAML frontmatter followed by Markdown content
- Use kebab-case for filenames (e.g., `api-standards.mdc`)

### YAML Frontmatter Properties
```yaml
---
description: Brief description for AI to decide relevance
globs: pattern/to/match/**/*  # Optional: auto-attach to matching files
alwaysApply: true/false        # Optional: always include in context
---
```

### Rule Types
- **Always Applied**: `alwaysApply: true` - Always included in AI context
- **Auto-Attached**: Has `globs` defined - Included when matching files are referenced
- **Agent Requested**: Has `description` only - AI decides whether to use it
- **Manual**: Empty frontmatter - Only used when explicitly invoked with `@ruleName`

### Best Practices
- Keep rules concise and focused (under 25 lines when possible)
- Show what TO do with minimal examples, not what NOT to do
- Use clear, actionable descriptions
- When documenting formats, provide one correct example
- Use `@filename` syntax to reference template files for additional context

### Updating Rules
1. Edit the `.mdc` file directly in `.cursor/rules/`
2. Changes take effect immediately in new AI conversations
3. Use numbered prefixes (e.g., `001-`, `100-`, `200-`) to control priority when using multiple rule files

## Modifying System Instructions
- To modify system instructions, edit the corresponding file in the `synced_files/system_instructions/` directory. These changes are automatically synced with the Supabase database via the `auto-sync` script.

## Database Schema and Data Migrations
- To modify the Supabase schema or perform data migrations, do **not** run raw SQL queries directly.
- Instead, modify the `alterCommands` array in `apply_and_verify_schema.cjs` with the required SQL DDL or DML commands.
- Run the script using `node apply_and_verify_schema.cjs`.
- After successful execution, **revert the changes** to the script.

## Console Logging for Usability
- When implementing or modifying any functionality (either locally or through a dispatched job), ensure that appropriate console logs are included to facilitate easier troubleshooting. All logs should be tagged with a descriptive, bracketed identifier.
- **Example:** `console.log('[Auth] User login successful:', userId);`

## Git Commit Guidelines
- **Do NOT commit changes unless explicitly instructed to do so by the user.**
- Making changes, staging files, and committing them should only happen when the user explicitly requests it.
- Feel free to make code changes, edits, and modifications as needed during the conversation, but do not automatically commit them.
- Wait for explicit instructions like "commit these changes" or "push this to main" before using git commands.

## Standard Development Workflow: Dispatching Agentic Tasks

Our primary method for making changes to the codebase is a collaborative, semi-automated process. This workflow allows us to dispatch tasks to an AI agent and track them through to completion and integration.

The typical steps are as follows:

1.  **Task Identification:** During our conversation, we will identify a specific development task, bug fix, or feature to be implemented.
2.  **Collaborative Prompting:** We will work together to craft a clear, detailed, and effective prompt that outlines the requirements for the task.
3.  **Job Dispatch:** Once the prompt is finalized, you will use the `dispatch_job` tool to send the task to the automated system. This creates a job record that appears in the local Dashboard UI.
4.  **Automated Execution:** The system will then trigger a GitHub Action that uses the Claude agent to perform the coding task, commit the result to a new branch, and create a pull request.
5.  **Preview and Verification:** A preview deployment is automatically generated for the pull request. The user will use the link in the Dashboard UI to access the preview and verify that the changes meet the requirements, using the provided verification steps.
6.  **Approval:** Using the Dashboard UI, the user will mark the verified jobs as "Ready for Integration."
7.  **Final Reconciliation:** When ready, the user will give you an instruction to integrate the approved changes. You will then execute the Job Reconciliation Workflow noted below to merge the code into the main branch.

## Job Dispatch Format

When calling `dispatch_job`, provide three required fields:

**1. title:** Brief job name

**2. prompt:** Full implementation instructions with code examples, file locations, and verification steps.

**Required Format:**

```
[Implementation instructions go here...]

**Verification Steps:**

1. Visual: Check button appears blue
2. Interaction: Click button, verify modal opens
3. Deployment: Test in Chrome and Firefox

---

At the end of your work, create a file named `INTEGRATION_SUMMARY.md` in the repository root that details what you did.

This summary will be included in the pull request for integration context.
```

Use `**Verification Steps:**` (markdown bold with colon), followed by blank line, then numbered list.

**Always include the INTEGRATION_SUMMARY.md instruction** in every job prompt. This document provides human-readable context that supplements the integration_summary field and helps reviewers understand the changes.

**3. integration_summary:** Comprehensive reconciliation context
- What is changing and why (no length limit)
- Key details (colors, elements, values)
- Original intent and purpose
- Used when merging multiple jobs that modify same files
- Omit implementation details (how)

**Example integration_summary:**
"Add blue (#2B5B84) background to Job Queue header frame (header_frame in create_job_list method). Purpose: Visual hierarchy - distinguish header from content area. Complements text styling changes to same element."

## Reviewing Job Changes

**When to use**: User asks you to evaluate, examine, or review jobs (e.g., "check the markdown jobs", "look at what the agents did", "evaluate which implementation is best").

**Workflow**:
```
1. list_all_jobs(limit: 20, status: "waiting_for_review")
   → Returns job metadata: ID, title, status, PR#, base_version
   → Omit status parameter to see all jobs regardless of status

2. get_job_diff(job_id: "uuid-here") 
   → Returns: filtered diff, integration_summary, job metadata
   → Call this for each job you want to examine
   → Use to understand what changed before deciding to integrate
```

## Implementation Fan-Out Protocol

**When to use**: When facing a technically complex or uncertain problem where the optimal solution approach is unclear, or when the user explicitly requests casting a "wide net" of different implementation strategies.

### Core Concept

Dispatch **multiple independent jobs** (typically 5) with **intentionally diverse approaches** to maximize the probability that at least one succeeds brilliantly. Each job attacks the same goal but varies along multiple dimensions.

### Dimensions to Vary

Create diversity across these axes and any others that the user may suggest:

**1. Programmatic Approach**
- Library-based vs. custom implementation
- Conventional patterns vs. innovative techniques
- Minimal dependencies vs. feature-rich solutions

**2. Intensity & Persistence**
- MEDIUM: "Balanced, thoughtful approach"
- HIGH: "Push boundaries, explore deeply"
- VERY HIGH: "Will NOT stop until perfect, no compromises"

**3. Research Directive**
- LOW: Minimal external research, rely on knowledge
- MEDIUM: Strategic research on key decision points
- HIGH: Extensive WebSearch/WebFetch before coding
- VERY HIGH: "Research voraciously, call WebSearch 10+ times, steal ideas from everywhere"

**4. Philosophy & Success Criteria**
- "Stand on giants' shoulders" (use proven libraries)
- "Perfect or nothing" (zero compromises)
- "Innovate boldly" (cutting-edge techniques)

### Prompt Construction Strategy

**For each job, explicitly state:**
- The specific approach philosophy
- Intensity level with directive language ("You MUST..." vs. "Consider...")
- Research expectations ("Call WebSearch at least X times..." or "Minimal external research...")
- Success criteria unique to that approach
- Trade-offs that approach accepts vs. rejects

**Research Bias**: When in doubt, ensure at least 2-3 research-intensive approaches with explicit directives to use WebSearch and WebFetch liberally for finding proven solutions, established libraries, and production patterns.

### Example Matrix

| Job | Approach | Intensity | Research | Philosophy |
|-----|----------|-----------|----------|------------|
| #1 | Established library | Medium | ⭐⭐⭐⭐⭐ | "Use proven tools" |
| #2 | Pure custom code | Very High | ⭐ | "Perfect, zero deps" |
| #3 | Quick hacks | Low | ⭐⭐⭐⭐⭐ | "Ship fast" |
| #4 | Cutting-edge APIs | High | ⭐⭐⭐⭐⭐ | "Innovate" |
| #5 | Enterprise-grade | Very High | ⭐⭐⭐ | "Production-ready" |


## Job Integration Workflow  

**When to use**: User explicitly instructs you to integrate/reconcile/commit completed jobs (i.e., you're applying the changes NOW, not just reviewing).

**Workflow**:
```
1. get_ready_jobs_for_integration()
   → Returns ONLY jobs marked ready_for_integration: true
   → Includes diffs and integration_summary for each job
2. **Reiterate the Integration Protocol below before beginning**
3. List all changes from diffs
4. **Go through each change ONE AT A TIME individually** - apply using `search_replace`/`write` tools per Integration Protocol
5. Run: `node integrate-jobs.cjs "title1" "title2" ...`
6. Call `mark_jobs_integrated()` MCP tool with job IDs

### Integration Protocol

**BEFORE STARTING INTEGRATION, REITERATE THIS PROTOCOL:**

- **THIS IS INTEGRATION, NOT REIMPLEMENTATION.**
- **GO THROUGH EACH CHANGE ONE AT A TIME** - Do NOT look at the whole file and come up with a solution
- **EVALUATE EACH CHANGE INDIVIDUALLY** - Process each diff change separately, one by one
- Apply each diff change exactly as written unless it conflicts
- Where conflicts exist, use integration_summary context to resolve intelligently
- **STRONGLY FAVOR reusing existing work over rewriting**
- After all changes applied, report any conflicts encountered
- **CRITICAL: Go through each change from each diff individually, one at a time, without reimplementing.**

## Mobile Device Specifications and Testing Guidelines

### Primary Target Device

**Samsung Galaxy S25+**
- Display Resolution: 1080 x 2120 pixels (device pixels)
- Physical Screen Size: 6.7 inches
- Pixel Density: ~393 PPI
- Viewport: Responsive (uses standard viewport meta tag)
- Default viewport width: 360-412 CSS pixels (depending on device DPI scaling)

### Secondary Target Devices

**Desktop Browsers**
- Minimum width: 1280px
- Typical widths: 1280px, 1366px, 1920px, 2560px
- Must maintain all functionality from mobile

### Testing Breakpoints

Test at the following viewport widths to ensure proper responsive behavior:

**Mobile (Portrait)**
- 360px - Small mobile devices
- 414px - iPhone Plus/Max devices
- 393px - Samsung Galaxy S25+ effective width

**Tablet**
- 768px - iPad portrait
- 1024px - iPad landscape

**Desktop**
- 1280px - HD laptop
- 1920px - Full HD desktop
- 2560px - QHD desktop

### Responsive Design Requirements

**Viewport Configuration**
```html
<meta name="viewport" content="width=device-width, initial-scale=1.0">
```

**Overflow Prevention**
- Apply `overflow-x: hidden` to html, body, and #root
- Use `min-width: 0` on flex/grid children to prevent overflow
- Avoid fixed pixel widths on mobile; use percentages, vw, or flexbox
- Apply `max-width: 100%` to images and media elements

**Touch Targets**
- Minimum touch target size: 44x44px (iOS) or 48x48px (Android Material Design)
- Icons in button contexts: 20px (h-5 w-5) with adequate padding
- Ensure adequate spacing between interactive elements

**Safe Areas**
- Account for device notches and rounded corners
- Test positioning of fixed/absolute elements near screen edges
- Ensure critical UI elements are not obscured by system UI

### Mobile-Specific Optimizations

**Chat Interface**
- Single-line input by default (rows={1}) with auto-expansion
- Full-width messages for better space utilization
- Minimal padding on scroll containers (pt-0 pb-0)
- Edge-aligned navigation buttons (left: 0)

**Typography**
- Base font size: 16px (to prevent iOS zoom on input focus)
- Line height: 1.5 for readability
- Relative units (rem, em) for scalability

**Performance**
- Minimize layout shifts during loading
- Use CSS transforms for animations (GPU-accelerated)
- Debounce resize/scroll handlers
- Lazy load off-screen content where applicable

### Cross-Platform Considerations

**Landscape vs Portrait**
- Test both orientations on mobile devices
- Account for reduced vertical space in landscape
- Ensure input fields remain accessible when keyboard appears

**Browser Differences**
- Test on Chrome (Android), Safari (iOS), and Firefox
- Account for browser-specific behaviors (e.g., iOS Safari address bar)
- Test with and without browser chrome visible

**Accessibility**
- Maintain keyboard navigation on desktop
- Ensure touch targets are accessible on mobile
- Test with screen readers (VoiceOver on iOS, TalkBack on Android)
- Maintain adequate color contrast ratios

### Verified Mobile Fixes (2025-10-31)

The following mobile layout issues have been addressed:

1. **Viewport Overflow**: Added overflow-x: hidden to html, body, and #root
2. **Chat Spacing**: Removed unnecessary top/bottom padding from ScrollArea
3. **Navigation**: Moved chat list button to left edge (left-0)
4. **Messages**: Full-width with subtle rounded corners (rounded-sm)
5. **Input**: Single-line default (rows={1}) with auto-expansion
6. **Icons**: Increased to 20px (h-5 w-5) for better touch accessibility
7. **Graph Controls**: Added rounded-tr-2xl for top-right corner styling
8. **Font Slider**: Removed to simplify UI and improve space utilization
